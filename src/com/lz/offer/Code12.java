package src.com.lz.offer;

/**
 * desc
 *
 * @author: liangzhen
 * @version: 1.0
 * @date: 2018-01-05
 * @since 1.8
 */

/**
 * 题目：
 * 实现函数power(int x,int y) 求x的y 次方，不得使用库函数，不考虑大数字
 * <p>
 * 思路1：实现次方乘积，那么我们第一个想到就是for循环累乘，没错这是一种方法，但是我们必须考虑输入的数字的特殊性
 * 对于power(0,0)是没有意义的，但是我们要考虑输入负指数的情况，只要我们求出正指数的结果，求倒数，即可。
 * 但是我们必须要考虑0的负指数，因为对0求倒数，是不允许的1/0 因为0不能做为被除数。顾思路1的陷阱在这里
 * <p>
 * ps 重要的一点：2个浮点数不能用==进行比较，这是计算机的误差导致的，应该使用x-y<10-9次方等
 * <p>
 * <p>
 * <p>
 * 思路2：
 * 我们分析，3的32次方 可以分解，等于3的16次方的平方， 3的16次方又等于3的8次方的平方!!!!依次类推，我们发现了这样一个规律
 * an次方=a n/2 次方 * a n/2次方 偶数
 * an次方= a n-1/2次方*a n-1/2次方*a 奇数
 * 但是这个方法只适应与正数次方的
 * <p>
 * 对于递归，我们一定要分析问题，分解问题，看能否分解为f(n)=f(n的函数）+（-)f(n的函数） 类似这样的公式，
 * 一旦可以分解，那么我们就可以使用递归，但是注意递归的结束条件。第二个就是使用递归的一半都是，前面的
 * 计算结果是后面结果的累计，我们就可以使用递归
 * <p>
 * ps 二进制>>1  为/2 我们不用说了把
 * 那么我们分析下为什么 x&0x1==1 就表示奇数呢?
 * 我们要知道  &运算 是 同为1 为1  不同为1 为0
 * 那么ox1  就是000000000001  ，而我们的数字转换为二进制后进行&运算，我们就发现前面都有0，所以
 * 前面的位全部位0，这也就叫屏蔽，它不管你原来的数字是多少，只要&运算后，就会变成0，只有最低位不确定，
 * 如果你最低位位1 ，那么结果就是1  否则就是0
 * 那么我们说说最低位为1的是什么情况，我们发现只要你二进制的最低位为1，那么就会有一个
 * 1*2 0次方=1 的一个因子，那么前面你计算的结果都是2的整数倍，肯定是偶数，那么+1 那么就变成了奇数，
 * 这就是使用&0x1来判断是否为奇数，效率很高，并且我们以后要多多在实际种使用，还有<<    >>这种操作
 */
public class Code12 {
    public double power(double x, int y) {
        if ((x - 0.0d) < 0.00000001 && y < 0) {
            return 0;//错误结果
        }
        int tempy = 0;
        if (y < 0) {
            tempy = -y;
        }
        double result = 1;
        for (int i = 0; i < tempy; i++) {
            result *= x;
        }
        if (y < 0) {
            //求倒数
            result = 1.0 / result;
        }
        return result;
    }

    public double pwoer2NoUnsign(double x, int y) {
        if (y == 0) {
            return 1;
        }
        if (y == 1) {
            return x;
        }
        double result = pwoer2NoUnsign(x, y >> 1);//这里使用了右移动来快速/2
        result *= result;
        if ((y & (0x1)) == 1) { //==1表示是奇数
            result *= x;
        }
        return result;
    }
}